diff --git a/docs/src/use/migrate-to-9.0.0.md b/docs/src/use/migrate-to-9.0.0.md
index 2a192ee46..9db6f4724 100644
--- a/docs/src/use/migrate-to-9.0.0.md
+++ b/docs/src/use/migrate-to-9.0.0.md
@@ -553,10 +553,11 @@ In order to aid in the development of high-quality custom rules that are free fr
 1. **Suggestions must generate valid syntax.** In order for rule suggestions to be helpful, they need to be valid syntax. `RuleTester` now parses the output of suggestions using the same language options as the `code` value and throws an error if parsing fails.
 1. **Test cases must be unique.** Identical test cases can cause confusion and be hard to detect manually in a long test file. Duplicates are now automatically detected and can be safely removed.
 1. **`filename` and `only` must be of the expected type.** `RuleTester` now checks the type of `filename` and `only` properties of test objects. If specified, `filename` must be a string value. If specified, `only` must be a boolean value.
+1. **Messages cannot have unsubstituted placeholders.** The `RuleTester` now also checks if there are {% raw %}`{{ placeholder }}` {% endraw %} still in the message as their values were not passed via `data` in the respective `context.report()` call.

 **To address:** Run your rule tests using `RuleTester` and fix any errors that occur. The changes you'll need to make to satisfy `RuleTester` are compatible with ESLint v8.x.

-**Related Issues(s):** [#15104](https://github.com/eslint/eslint/issues/15104), [#15735](https://github.com/eslint/eslint/issues/15735), [#16908](https://github.com/eslint/eslint/issues/16908)
+**Related Issues(s):** [#15104](https://github.com/eslint/eslint/issues/15104), [#15735](https://github.com/eslint/eslint/issues/15735), [#16908](https://github.com/eslint/eslint/issues/16908), [#18016](https://github.com/eslint/eslint/issues/18016)

 ## <a name="flat-eslint"></a> `FlatESLint` is now `ESLint`

diff --git a/lib/linter/index.js b/lib/linter/index.js
index 25fd769bd..795a414ab 100644
--- a/lib/linter/index.js
+++ b/lib/linter/index.js
@@ -1,7 +1,7 @@
 "use strict";

 const { Linter } = require("./linter");
-const interpolate = require("./interpolate");
+const { interpolate } = require("./interpolate");
 const SourceCodeFixer = require("./source-code-fixer");

 module.exports = {
diff --git a/lib/linter/interpolate.js b/lib/linter/interpolate.js
index 87e06a023..5f4ff9227 100644
--- a/lib/linter/interpolate.js
+++ b/lib/linter/interpolate.js
@@ -9,13 +9,30 @@
 // Public Interface
 //------------------------------------------------------------------------------

-module.exports = (text, data) => {
+/**
+ * Returns a global expression matching placeholders in messages.
+ * @returns {RegExp} Global regular expression matching placeholders
+ */
+function getPlaceholderMatcher() {
+    return /\{\{([^{}]+?)\}\}/gu;
+}
+
+/**
+ * Replaces {{ placeholders }} in the message with the provided data.
+ * Does not replace placeholders not available in the data.
+ * @param {string} text Original message with potential placeholders
+ * @param {Record<string, string>} data Map of placeholder name to its value
+ * @returns {string} Message with replaced placeholders
+ */
+function interpolate(text, data) {
     if (!data) {
         return text;
     }

+    const matcher = getPlaceholderMatcher();
+
     // Substitution content for any {{ }} markers.
-    return text.replace(/\{\{([^{}]+?)\}\}/gu, (fullMatch, termWithWhitespace) => {
+    return text.replace(matcher, (fullMatch, termWithWhitespace) => {
         const term = termWithWhitespace.trim();

         if (term in data) {
@@ -25,4 +42,9 @@ module.exports = (text, data) => {
         // Preserve old behavior: If parameter name not provided, don't replace it.
         return fullMatch;
     });
+}
+
+module.exports = {
+    getPlaceholderMatcher,
+    interpolate
 };
diff --git a/lib/linter/report-translator.js b/lib/linter/report-translator.js
index 91fef4d95..c4a159a99 100644
--- a/lib/linter/report-translator.js
+++ b/lib/linter/report-translator.js
@@ -11,7 +11,7 @@

 const assert = require("assert");
 const ruleFixer = require("./rule-fixer");
-const interpolate = require("./interpolate");
+const { interpolate } = require("./interpolate");

 //------------------------------------------------------------------------------
 // Typedefs
diff --git a/lib/rule-tester/rule-tester.js b/lib/rule-tester/rule-tester.js
index bc728159f..261a1bb73 100644
--- a/lib/rule-tester/rule-tester.js
+++ b/lib/rule-tester/rule-tester.js
@@ -17,7 +17,8 @@ const
     equal = require("fast-deep-equal"),
     Traverser = require("../shared/traverser"),
     { getRuleOptionsSchema } = require("../config/flat-config-helpers"),
-    { Linter, SourceCodeFixer, interpolate } = require("../linter"),
+    { Linter, SourceCodeFixer } = require("../linter"),
+    { interpolate, getPlaceholderMatcher } = require("../linter/interpolate"),
     stringify = require("json-stable-stringify-without-jsonify");

 const { FlatConfigArray } = require("../config/flat-config-array");
@@ -304,6 +305,39 @@ function throwForbiddenMethodError(methodName, prototype) {
     };
 }

+/**
+ * Extracts names of {{ placeholders }} from the reported message.
+ * @param   {string} message Reported message
+ * @returns {string[]} Array of placeholder names
+ */
+function getMessagePlaceholders(message) {
+    const matcher = getPlaceholderMatcher();
+
+    return Array.from(message.matchAll(matcher), ([, name]) => name.trim());
+}
+
+/**
+ * Returns the placeholders in the reported messages but
+ * only includes the placeholders available in the raw message and not in the provided data.
+ * @param {string} message The reported message
+ * @param {string} raw The raw message specified in the rule meta.messages
+ * @param {undefined|Record<unknown, unknown>} data The passed
+ * @returns {string[]} Missing placeholder names
+ */
+function getUnsubstitutedMessagePlaceholders(message, raw, data = {}) {
+    const unsubstituted = getMessagePlaceholders(message);
+
+    if (unsubstituted.length === 0) {
+        return [];
+    }
+
+    // Remove false positives by only counting placeholders in the raw message, which were not provided in the data matcher or added with a data property
+    const known = getMessagePlaceholders(raw);
+    const provided = Object.keys(data);
+
+    return unsubstituted.filter(name => known.includes(name) && !provided.includes(name));
+}
+
 const metaSchemaDescription = `
 \t- If the rule has options, set \`meta.schema\` to an array or non-empty object to enable options validation.
 \t- If the rule doesn't have options, omit \`meta.schema\` to enforce that no options can be passed to the rule.
@@ -997,6 +1031,18 @@ class RuleTester {
                                 error.messageId,
                                 `messageId '${message.messageId}' does not match expected messageId '${error.messageId}'.`
                             );
+
+                            const unsubstitutedPlaceholders = getUnsubstitutedMessagePlaceholders(
+                                message.message,
+                                rule.meta.messages[message.messageId],
+                                error.data
+                            );
+
+                            assert.ok(
+                                unsubstitutedPlaceholders.length === 0,
+                                `The reported message has ${unsubstitutedPlaceholders.length > 1 ? `unsubstituted placeholders: ${unsubstitutedPlaceholders.map(name => `'${name}'`).join(", ")}` : `an unsubstituted placeholder '${unsubstitutedPlaceholders[0]}'`}. Please provide the missing ${unsubstitutedPlaceholders.length > 1 ? "values" : "value"} via the 'data' property in the context.report() call.`
+                            );
+
                             if (hasOwnProperty(error, "data")) {

                                 /*
@@ -1096,6 +1142,18 @@ class RuleTester {
                                                 expectedSuggestion.messageId,
                                                 `${suggestionPrefix} messageId should be '${expectedSuggestion.messageId}' but got '${actualSuggestion.messageId}' instead.`
                                             );
+
+                                            const unsubstitutedPlaceholders = getUnsubstitutedMessagePlaceholders(
+                                                actualSuggestion.desc,
+                                                rule.meta.messages[expectedSuggestion.messageId],
+                                                expectedSuggestion.data
+                                            );
+
+                                            assert.ok(
+                                                unsubstitutedPlaceholders.length === 0,
+                                                `The message of the suggestion has ${unsubstitutedPlaceholders.length > 1 ? `unsubstituted placeholders: ${unsubstitutedPlaceholders.map(name => `'${name}'`).join(", ")}` : `an unsubstituted placeholder '${unsubstitutedPlaceholders[0]}'`}. Please provide the missing ${unsubstitutedPlaceholders.length > 1 ? "values" : "value"} via the 'data' property for the suggestion in the context.report() call.`
+                                            );
+
                                             if (hasOwnProperty(expectedSuggestion, "data")) {
                                                 const unformattedMetaMessage = rule.meta.messages[expectedSuggestion.messageId];
                                                 const rehydratedDesc = interpolate(unformattedMetaMessage, expectedSuggestion.data);
